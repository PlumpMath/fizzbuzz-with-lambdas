{"name":"FizzBuzz with Lambdas","tagline":"Functional implementation of FizzBuzz in different languages","body":"# FizzBuzz with Lambdas\r\n\r\n<img align=\"right\" width=\"150\"\r\nsrc=\"http://raw.github.com/scotthaleen/fizzbuzz-with-lambdas/master/lambda.png\" />\r\n\r\nFunctional implementation of\r\n[FizzBuzz](http://en.wikipedia.org/wiki/Fizz_buzz) using lambdas\r\n\r\nThis started as a project to make use of Java 8's new lambda\r\nexpressions but I decided to implement the same (similar) functional\r\nlogic in\r\n[Java](https://github.com/scotthaleen/fizzbuzz-with-lambdas/tree/master/java8),\r\n[Scala](https://github.com/scotthaleen/fizzbuzz-with-lambdas/tree/master/scala),\r\nand \r\n[Clojure](https://github.com/scotthaleen/fizzbuzz-with-lambdas/tree/master/clojure)\r\nas comparisons.\r\n\r\n\r\nThe functional logic basically follows this\r\n\r\n<hr />\r\n\r\n\\- Define a base function that takes a predicate and a **String**\r\nand returns a function that takes an **Integer**.  <br />If the predicate is\r\nmet return the **String**, if not return **None/Empty/nil**\r\n```\r\n((Int) ⇒ Boolean, String) ⇒ (Int) ⇒ Optional[String]\r\n```\r\n```java\r\nstatic final Function<Predicate<Integer>, \r\n        Function<String, Function<Integer, Optional<String>>>>\r\n   isaFizzBuzz = p -> sz -> i -> {\r\n      if (p.test(i)) return Optional.of(sz);\r\n         return Optional.empty();\r\n      };\r\n```\r\n```scala\r\n  def isaFizzBuzz(p:(Int) => Boolean, sz:String) =\r\n    (i:Int) =>\r\n      if (p(i)) Some(sz)\r\n      else None\r\n```\r\n```clojure\r\n(defn isaFizzBuzz [pred sz]\r\n  (fn [i] (cond (pred i) sz)))\r\n```\r\n\\- Define higher order functions from the base function by partially\r\napplying the predicate and string\r\n\r\n```\r\n(Int) ⇒ Optional[String]\r\n```\r\n```java\r\nFunction<Integer, Optional<String>>\r\n   isFizz = isaFizzBuzz.apply(i -> (i % 3) == 0).apply(\"Fizz\");\r\n```\r\n```scala\r\ndef isFizz = isaFizzBuzz((x) => x % 3 == 0, \"Fizz\")\r\n```\r\n```clojure\r\n(def isFizz\r\n  (isaFizzBuzz\r\n   (fn [x] (= 0 (mod x 3)))\r\n   \"Fizz\"))\r\n```\r\n\\- Create an ordered sequence of the functions to apply to each number.\r\n(juxtaposition)\r\n\r\n```java\r\nList<Function<Integer, Optional<String>>>\r\n   conditions = Arrays.asList(isFizz, isBuzz);\r\n```\r\n```scala\r\nval conditions = List(isFizz, isBuzz)\r\n```\r\n```clojure\r\n(def conditions (juxt isFizz isBuzz))\r\n```\r\n\r\n\\- Define a combination function for joining **Optional[String]s** and\r\n**None**. \r\n* **String** + **String** = **Combined Strings**\r\n* **String** + **nil** = **String**\r\n* **nil** + **nil** = **nil**. \r\n\r\n```java\r\nstatic final BinaryOperator<Optional<String>>\r\n   combiner = (Optional<String> a, Optional<String> b) -> {\r\n      if (a.isPresent() && b.isPresent()) return Optional.of(a.get() + b.get());\r\n         if (a.isPresent()) return a;\r\n            return b;\r\n      };\r\n```\r\n```scala\r\n  def combine(a:Option[String], b:Option[String]):Option[String] =\r\n    (a,b) match {\r\n      case (Some(s1), Some(s2)) => Some(s1 + s2)\r\n      case (Some(_), None) => a\r\n      case (None, Some(_)) => b\r\n      case (_,_) => None\r\n    }\r\n```\r\n**clojure** handles this a bit differently because **str** will combine **nil**\r\nand a **String** and **nil** + **nil** results in **\"\"** we can just\r\nuse the **empty?** on **\"\"** to achieve similar results to the\r\n**Optional** **None** \r\n```clojure\r\n(reduce str (conditions i))\r\n```\r\n\r\n\\- Reduce the results of applying each function and joining the strings\r\ntogether with the combination function, to produce an optional\r\n**String**. If the result is **None/nil** return the input number as a\r\n**String**. \r\n```\r\n(Int) ⇒ String\r\n```\r\n```java\r\ni -> conditions.stream().sequential()\r\n   .reduce(\r\n      emptyString,\r\n      (s, fn) -> combiner.apply(s, fn.apply(i)),\r\n      (xs, x) -> combiner.apply(xs, x)\r\n   ).orElse(String.valueOf(i))\r\n```\r\n```scala\r\n(i) =>\r\n   conditions.foldLeft(emptyString) {\r\n      (xs, fn) => combine(xs, fn(i))\r\n  }.orElse(Some(i.toString)).get)\r\n```\r\n```clojure\r\n(fn [i]\r\n   (let [sz (reduce str (conditions i))]\r\n       (if (empty? sz)\r\n           (str i)\r\n           sz)))\r\n```\r\n\r\n\\- Take the range from **1..N** and **map/apply** the function and print the\r\nresults to the console. \r\n\r\n```java\r\nIntStream.iterate(1, inc)\r\n   .limit(limit)\r\n   .mapToObj(i ->\r\n      conditions.stream().sequential()\r\n         .reduce(\r\n            emptyString,\r\n            (s, fn) -> combiner.apply(s, fn.apply(i)),\r\n            (xs, x) -> combiner.apply(xs, x)\r\n         ).orElse(String.valueOf(i))\r\n   ).forEach(System.out::println);\r\n```\r\n```scala\r\n  Stream.from(1)\r\n    .take(limit)\r\n    .map((i) =>\r\n        conditions.foldLeft(emptyString) {\r\n          (xs, fn) => combine(xs, fn(i))\r\n        }.orElse(Some(i.toString)).get)\r\n    .foreach(println)\r\n```\r\n```clojure\r\n(doseq [x (map fizzbuzz\r\n               (range 1 (inc limit)))]\r\n  (println x))\r\n```\r\n\r\n\r\n```\r\n1\r\n2\r\nFizz\r\n4\r\nBuzz\r\nFizz\r\n7\r\n8\r\nFizz\r\nBuzz\r\n11\r\nFizz\r\n13\r\n14\r\nFizzBuzz\r\n16\r\n17\r\nFizz\r\n19\r\nBuzz\r\n```\r\n\r\n<hr />\r\n\r\n\r\n### Break Down of Logic (java)\r\n\r\nBasically we want a Range of numbers from 1..N and for each number\r\napply some function that will return the String to print or the number\r\nitself if no conditions are met. \r\n\r\nThe **isaFizzBuzz** function is a way to\r\n[curry](http://en.wikipedia.org/wiki/Curry_(programming_language)) the\r\nlogic being applied to each number.  It allows you to create a partial\r\nfunction with the Predicate and String to return if the predicate is\r\nmet. \r\n\r\n```java\r\nFunction<Predicate<Integer>, Function<String, Function<Integer, Optional<String>>>> isaFizzBuzz =\r\n p -> sz -> i -> {\r\n    if (p.test(i)) return Optional.of(sz);\r\n    return Optional.empty(); \r\n };\r\n```\r\n\r\nWith this function we can now create higher order functions defining\r\n**isFizz** and **isBuzz** \r\n\r\nthis is pseudo equivalent to this\r\n```\r\nisFizz = isaFizzBuzz(λ i -> (i % 3) == 0, \"Fizz\")\r\n```\r\n\r\n\r\nThe next chunk of logic to tackle is applying each function to a\r\nnumber.  This could be done with if/else or case/switch or possibly\r\n[Optional.orElse](http://download.java.net/jdk8/docs/api/java/util/Optional.html#orElse-T-).\r\nI preferred to create a List of the function\r\nthat I want them to be applied. By using an ordered List I can\r\njust apply the functions and combine the results.  This is the reason\r\nfor implementing the `BinaryOperator<Optional<String>>` **combiner**.\r\nThis could alternatively be achieved if there was some kind of\r\njuxtaposition function like in [clojure](http://clojuredocs.org/clojure_core/clojure.core/juxt)\r\n\r\nThis logic follows, apply the function on *i* combine the results with\r\nthe previous result.  If the predicate does not pass the function just\r\nreturns *empty*.  This means if all of the functions applied and none of\r\nthe predicates are matched I can make use of the\r\n[Optional.orElse](http://download.java.net/jdk8/docs/api/java/util/Optional.html#orElse-T-)\r\nto get the string value of the number and display it. And if multiple\r\nconditions are met like with **15**, Fizz and Buzz will be combined to\r\nprint out **FizzBuzz**\r\n\r\nThat covers what is going on in this chunk of code\r\n```java\r\n  .mapToObj(i ->\r\n     conditions.stream().sequential()\r\n     .reduce(\r\n        emptyString,\r\n        (s, fn) -> combiner.apply(s, fn.apply(i)),\r\n        (xs, x) -> combiner.apply(xs, x))\r\n     .orElse(String.valueOf(i))\r\n```\r\n                                                                                \r\nWhat I like about this solution is the composability of this solution.\r\nIt actually follows the\r\n[open/closed principle](http://en.wikipedia.org/wiki/Open/closed_principle)\r\nalthough obviously not OO.\r\n\r\nIf we want to extend this solution and say we want to add \"Woof\" for\r\nevery multiple of 7. It only requires 2 changes\r\n\r\nThe new partial function composed from the **isaFizzBuzz** function\r\n```java\r\nFunction<Integer, Optional<String>>\r\n   isWoof = isaFizzBuzz.apply(i -> (i % 7) == 0).apply(\"Woof\");\r\n```\r\n\r\nAnd then add the new function to the end of the conditions list\r\n\r\n```java\r\nList<Function<Integer, Optional<String>>>\r\n   conditions = Arrays.asList(isFizz, isBuzz, isWoof);\r\n```\r\n\r\n```\r\n$ ./run.sh 25\r\n1\r\n2\r\nFizz\r\n4\r\nBuzz\r\nFizz\r\nWoof\r\n8\r\nFizz\r\nBuzz\r\n11\r\nFizz\r\n13\r\nWoof\r\nFizzBuzz\r\n16\r\n17\r\nFizz\r\n19\r\nBuzz\r\nFizzWoof\r\n22\r\n23\r\nFizz\r\nBuzz\r\n```\r\n\r\nAnd we can very easily keep going \r\n\r\n```java\r\nFunction<Integer, Optional<String>>\r\n   isMeow = isaFizzBuzz.apply(i -> (i % 9) == 0).apply(\"Meow\");\r\n\r\nList<Function<Integer, Optional<String>>>\r\n   conditions = Arrays.asList(isFizz, isBuzz, isWoof, isMeow);\r\n```\r\n\r\n```\r\n$ ./run.sh 25\r\n1\r\n2\r\nFizz\r\n4\r\nBuzz\r\nFizz\r\nWoof\r\n8\r\nFizzMeow\r\nBuzz\r\n11\r\nFizz\r\n13\r\nWoof\r\nFizzBuzz\r\n16\r\n17\r\nFizzMeow\r\n19\r\nBuzz\r\nFizzWoof\r\n22\r\n23\r\nFizz\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}